var store = [{
        "title": "안녕하세요",
        "excerpt":"새 블로그 입니다.   2020-01-26 12:47:03 +0900   ","categories": ["Jekyll","Update"],
        "tags": [],
        "url": "https://jerry901.github.io/2020/01/2020-01-26-01/",
        "teaser":null},{
        "title": "우분투 18.04 LTS 환경에서 Jekyll 설치",
        "excerpt":" 오래전부터 기술 블로그를 개설하기위한 시도를 해왔지만 매번 작업 환경을 구성하는 단계에서 포기했습니다. 많은 시간을 투자한 끝에 Github pages와 호환되는 Jekyll plugin을 이용해 블로그를 빌드하는데 성공했고,  오늘은 우분투 18.04 LTS 환경에서 Jekyll을 설치하는 방법과 이를 이용해 정적 페이지 프로젝트를 생성하는 법에 대해 포스팅하고자 합니다.   작업 환경설정   Jekyll은 Ruby로 개발되었습니다. 따라서 설치를 위해 먼저 Ruby를 설치합니다. Ruby로 작성된 소프트웨어들은 적용되는 버젼이 각각 다르기 때문에 패키지 관리자를 통해 단일 버젼만을 설치하게되면 추후 의존성 문제를 겪게 될 수 있습니다. 따라서 이 포스트에서는 rbenv을 이용해 Ruby를 설치합니다. 이렇게 하면 필요에 따라 다른 버젼의 Ruby를 선택하여 사용할 수 있습니다.    - 패키지 리스트 업데이트 및 의존 라이브러리 설치   $ sudo apt-get update  $ sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev software-properties-common libffi-dev nodejs    - rbenv 설치   $ git clone https://github.com/rbenv/rbenv.git ~/.rbenv    - rbenv 환경변수 설정   아래 명령어들을 실행하면 해당 내용이 ~/.bashrc 파일에 추가된 것을 확인할 수 있습니다.  zsh shell을 사용하는 경우 ~/.zshrc 파일을 확인하시기 바랍니다.   $ echo 'export PATH=\"$HOME/.rbenv/bin:$PATH\"' &gt;&gt; ~/.bashrc  $ echo 'eval \"$(rbenv init -)\"' &gt;&gt; ~/.bashrc  $ exec $SHELL    - ruby-build 설치   $ git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build  $ echo 'export PATH=\"$HOME/.rbenv/plugins/ruby-build/bin:$PATH\"' &gt;&gt; ~/.bashrc  $ exec $SHELL    - rbenv 해시 재정렬   $ rbenv rehash    - Ruby 설치   2.6.3 버젼을 사용하며 큰 문제없이 잘 사용 중이므로 2.6.3 버젼을 선택했지만 버젼 선택은 개인의 환경에 맞게 설정합니다.   $ rbenv install 2.6.3   $ rbenv global 2.6.3   $ rbenv rehash    - 지킬 설치   rbenv를 이용해 Ruby를 설치하게되면 gem이 함께 설치됩니다. gem은 apt와 같은 패키지 관리자 역할을 수행합니다.   $ gem install jekyll   - bundler 설치   설치된 gem이 또 다른 gem을 의존하는 경우, Gemfile이라는 파일에 의존성들을 기술하여 bundle install이라는 명령어를 통해 일괄적으로 설치할 수 있습니다.   $ gem install bundler   Jekyll 시작    - 새 프로젝트 생성   프로젝트를 생성하고 해당 경로로 이동해 jekyll serve 명령어를 실행하면 로컬에서 블로그 화면을 볼 수 있습니다.   깃허브 블로그를 생성할 목적이라면 프로젝트명을 githubId.github.io의 형식으로 하는것이 일반적입니다.   $ Jekyll new project_name    $ cd project_name  ~/project_name $ jekyll serve    - bundler 활용 예  프로젝트 폴더로 이동해 Gemfile을 열어줍니다.   $ cd ~/project_name   $ vi Gemfile  맨 아랫줄에 다음과 같은 의존성을 기록합니다.   gem 'jekyll-admin', group: :jekyll_plugins  기록된 의존성에 따른 플러그인들을 설치하고 jekyll serve 명령을 실행합니다.   $ bundle install  $ cd ~/project_name  $ jekyll serve   http://localhost:4000/admin/ 로 연결하면, admin 페이지를 확인할 수 있습니다.   References    - Stack overflow - How do RVM and rbenv actually work?  ","categories": ["Jekyll"],
        "tags": [],
        "url": "https://jerry901.github.io/2020/01/2020-01-26-02/",
        "teaser":null},{
        "title": "Vim editor 설정",
        "excerpt":" 현재 제가 사용하고있는 vim editor의 설정을 공유합니다. 다음 내용을 ~/.vimrc 파일에 붙여넣으면 설정 내용들이 동작합니다.  만약 .vimrc 파일이 존재하지 않는다면 다음 명령어를 실행해주세요.   $ touch ~/.vimrc        $ vi ~/.vimrc  \" 구문강조 사용 syntax on   set nocompatible  \" 검색어 하이라이팅  set hlsearch   \" 줄번호  set nu   \" 자동 들여쓰기 set autoindent   set scrolloff=2  set wildmode=longest,list   \" tag select  set ts=4   \" st select  set sts=4   \" 스크롤바 너비 set sw=1   \" 다른 파일로 넘어갈 때 자동 저장 set autowrite   \" 작업 중인 파일 외부에서 변경됬을 경우 자동으로 불러옴 set autoread   \" C언어 style 자동 들여쓰기 set cindent   set history=100  \" 상태바 표시 항상 set laststatus=2   \" 들여쓰기 너비 설정 set shiftwidth=4   set smarttab set smartindent set softtabstop=4 set tabstop=4  \" 현재 커서 위치 표시 set ruler   set statusline=\\ %&lt;%l:%v\\ [%P]%=%a\\ %h%m%r\\ %F\\  \" 파일저장인코딩  set fileencoding=utf-8   \" 줄의 끝, 시작, 들여쓰기에서 백스페이스시 이전줄로 set backspace=eol,start,indent   \" 키워드 입력시 점진적 검색 set incsearch   \" 검색시 대소문자 무시, set ic 도 가능 set ignorecase   \" 터미널 인코딩 set tenc=utf-8        \" 한글 파일은 euc-kr로, 유니코드는 유니코드로 set fencs=ucs-bom,utf-8,euc-kr.latin1   \"Key mappings Leader key 설정 let mapleader=\",\"  \" 마우스 사용 여부 \" on map &lt;F7&gt; &lt;ESC&gt;:set mouse=a&lt;CR&gt; \" off map &lt;F8&gt; &lt;ESC&gt;:set mouse-=a&lt;CR&gt;  \" moving \" insert mode inoremap jk &lt;esc&gt;  \" normal mode nnoremap &lt;S-l&gt; $ nnoremap &lt;S-h&gt; ^ nnoremap d&lt;S-l&gt; d$ nnoremap d&lt;S-h&gt; d^ nnoremap &lt;Tab&gt; &gt;&gt; nnoremap &lt;S-Tab&gt; &lt;&lt; nnoremap &lt;C-k&gt; :m--&lt;CR&gt;== nnoremap &lt;C-j&gt; :m +1&lt;CR&gt;== nnoremap &lt;S-k&gt; k  \"실수로 help 열지 않기 위한 맵핑 nnoremap &lt;leader&gt;h &lt;S-k&gt;  \" visual mode vnoremap &lt;S-l&gt; $ vnoremap &lt;S-h&gt; ^  ","categories": ["Linux"],
        "tags": [],
        "url": "https://jerry901.github.io/2020/01/2020-01-27-01/",
        "teaser":null},{
        "title": "Jekyll Github 블로그 생성 ",
        "excerpt":"  오늘은 이전 포스트 우분투 18.04 LTS 환경에서 Jekyll 설치에 이어, Jekyll을 활용하여 Github 블로그를 생성하는 방법에 대해 알아보겠습니다.   Github Repository 생성   먼저 Github 블로그의 테마, 포스트 등을 업로드할 저장소를 생성합니다. Repository name은 블로그의 도메인으로 사용될 것이므로 userName.github.io의 포맷으로 입력해주세요.      테마 선택    블로그의 테마를 다운받을 차례입니다. Jekyll Themes에서 마음에 드는 테마를 다운받아주세요. 본 포스트에서는 이 블로그의 테마인 Minimal Mistakes로 진행하겠습니다.  만약 다른 테마를 선택하셨다면 $ git clone 명령어의 URL 파라미터를 해당 테마의 URL로 변경해주세요.  $ cd ~ $ git clone https://github.com/mmistakes/minimal-mistakes.git  프로젝트 빌드   프로젝트 경로로 이동해 다음 명령어들을 실행합니다.  $ cd minimal-mistakes $ bundle exec jekyll serve  빌드가 성공적으로 진행되면 아래와 같은 내용을 볼 수 있습니다.  Configuration file: /home/userName/minimal-mistakes/_config.yml             Source: /home/userName/minimal-mistakes        Destination: /home/userName/minimal-mistakes/_site  Incremental build: disabled. Enable with --incremental       Generating...         Jekyll Feed: Generating feed for posts                     done in 0.199 seconds.  Auto-regeneration: enabled for '/home/userName/minimal-mistakes'     Server address: http://127.0.0.1:4000   Server running... press ctrl-c to stop.  이제 브라우저를 켜고 http://127.0.0.1:4000/ 또는 http://localhost:4000/로 연결하면 테마가 적용된 블로그를 확인할 수 있습니다.   원격 저장소에 업로드    처음에 만들었던 원격 저장소를 내려받고, 로컬 저장소에 minimal-mistakes를 복사한 후 커밋하면 정적 github 블로그가 생성됩니다.  $ cd ~ $ git clone 저장소_URL $ cp -r minimal-mistakes/* 로컬_저장소_폴더명 $ cd 로컬_저장소_폴더명 $ git add . $ git commit -m \"hello my blog\" $ git push origin master   몇 분 후 https://userName.github.io에서 블로그가 생성된 것을 확인 할 수 있습니다.  ","categories": ["Jekyll"],
        "tags": [],
        "url": "https://jerry901.github.io/2020/01/2020-01-27-02/",
        "teaser":null},{
        "title": "Github pages 다국어 기능 적용 가이드",
        "excerpt":" 이번 포스트에서는 Jekyll 플러그인을 이용해서 Github 블로그에 다국어를 적용하는 방법에 대해 포스팅하고자 한다.  다국어 기능을 구현하기 위해서는 다국어 플러그인을 사용하는 것이 수월한데, Github는 보안상의 이유로 몇몇 기본적인 플러그인 이외에 다른 플러그인들은 제공하지 않는다.  따라서 플러그인이 적용된 프로젝트를 업로드하면 프로젝트 빌드과정에서 오류가 발생하게된다. 하지만 방법이 아예 없는 것은 아니다.  새로운 branch를 만들어 지킬 프로젝트를 push하고 master branch에는 이미 빌드된 페이지를 push 한다면 Guthub에서 제공하는 자체적 빌드과정을 거치지 않고 직접 publishing 할 수 있다.  Gtihub blog의 다국어 적용에 관한 정보는 상대적으로 부족한 편인데, 이 포스트를 통해 많은 사람들이 글로벌한 깃허브 블로그를 운영하는데 도움이 되었으면 한다.   jekyll-multiple-languages 플러그인 설치   jekyll-multiple-languages-plugin을 설치하는 방법에는 몇가지가 있는데, 각자 사용하는 테마에 따라 gem의 의존성과 관련된 이슈가 발생할 수 있기 때문에 나는 git submodule을 이용한 방식을 선택했다. 먼저 Jekyll project의 root directory로 이동하여 다음과 같은 명령어를 실행한다.   $ git submodule add git://github.com/screeninteraction/jekyll-multiple-languages-plugin.git _plugins/multiple-languages  $ ls _plugins/  ls _plugins/ 명령어로 다음과 같은 결과가 나온다면 성공적으로 설치가 된 것이다.  multiple-languages   _config.yml 설정  languages에 제공하고자 하는 언어들을 입력한다. 첫번째 항목은 default language로 사용된다.  #languages languages: [\"ko\", \"en\"]   디렉토리 구조  Jekyll 프로젝트에서 우리는 포스트들을 project root 디렉토리의 _posts 폴더에 저장한다.  하지만 jekyll-multiple-languages-plugin 설치하면,  jekyl serve 명령은 _i18n 디렉토리 하위의 _posts 폴더를 빌드한다.  따라서, 다음과 같은 디렉토리 구조가 필요하다.  project_root/ -- _i18n/ ---- en/ ------ _post/ -------- yyyy-mm-dd-01.md # your posts / .md -------- yyyy-mm-dd-02.md -------- yyyy-mm-dd-03.md          ... ---- ko/ ------ _post/ -------- yyyy-mm-dd-01.md # your posts / .md -------- yyyy-mm-dd-02.md -------- yyyy-mm-dd-03.md          ... ---- en.yml ---- ko.yml   lanugages.yml 설정  en.yml (example)  global:   english: Eng    korean: Kor pages:   home: Home   work: Work titles:   pagination: Pagination  ko.yml (example)  global:   english: Eng    korean: Kor pages:   home: Home   work: Work titles:   pagination: Pagination   다국어 적용 페이지 접근하기  default 언어 (한국어 예시)   https://blogurl.io/yyyy-mm-dd-01  https://localhost:4000/yyyy-mm-dd-01   다국어 페이지 (영문 예시)   https://blogurl.io/en/yyyy-mm-dd-01  https://localhost:4000/en/yyyy-mm-dd-01   빌드된 소스 커밋하기  source branch 생성 및 default branch 설정    Local repository에서 다음과 같은 명령어들을 실행한다. (git push -u 옵션은 이후 부터는 브랜치를 지정하지 않고 ```git push`` 명령만으로 커밋을 할 수 있도록 하는 옵션이다.)   $ git checkout -b source master  $ git push -u origin source  그리고, Github web &gt; your repository &gt; Settings &gt; Branches &gt; Default branch 로 이동해 source branch를 default branch로 변경해준다.   Rakefile 작성    Jekyll project의 root directory에서 Rakefile을 열고, 다음과 같은 내용을 입력한다. (Rakefile이 없다면 새로 만든다.)  # Auto publish # Change your GitHub reponame GITHUB_REPONAME = \"username/username.github.io\"  desc \"Generate blog files\" task :generate do   Jekyll::Site.new(Jekyll.configuration({     \"source\"      =&gt; \".\",     \"destination\" =&gt; \"_site\"   })).process end  desc \"Generate and publish blog to gh-pages\" task :publish =&gt; [:generate] do   Dir.mktmpdir do |tmp|     cp_r \"_site/.\", tmp      pwd = Dir.pwd     Dir.chdir tmp      system \"git init\"     system \"git add .\" \tmessage = \"Site updated at #{Time.now.utc}\" \tsystem \"git commit -m #{message.inspect}\"     system \"git remote add origin https://github.com/#{GITHUB_REPONAME}.git\"     system \"git push origin master --force\"      Dir.chdir pwd   end end  Run rake publish    이제 rake publish 또는 bundle exec rake publish 커맨드를 입력하면 master branch에 정적 사이트들이 업로드 될 것이며, git push를 하면 source branch에 지킬 프로젝트가 업로드 될 것이다.   언어 선택 버튼 만들기    다국어 적용이 되었으면 언어 선택 버튼도 필요할 것이다.. 이 블로그의 언어 선택 버튼 소스를 공유한다. 아래 내용을 masthead.html 파일의 &lt;nav&gt; 태그 아래에 추가하였다. (css는 취향에 맞게..)   &lt;nav id=\"lang-sel\" &gt;     &lt;ul class=\"lang\"&gt;         {% capture link1 %}{{ site.baseurl_root }}{{ page.url}}{% endcapture %}         {% capture link2 %}{{ site.baseurl_root }}/en{{ page.url}}{% endcapture %}         {% if site.lang == \"ko\" %}         &lt;li class=\"masthead_menu-item visible-links\"&gt; \t        &lt;a href=\"{{ link1 }}\" class=\"enabled\"&gt;{% t global.korean%} &lt;/a&gt;|&lt;a href=\"{{ link2 }}\"&gt; {% t global.english%}&lt;/a&gt;         &lt;/li&gt;         {% elsif site.lang == \"en\" %}         &lt;li class=\"masthead_menu-item lang\"&gt; \t        &lt;a href=\"{{ link1 }}\"&gt;{% t global.korean%} &lt;/a&gt;|&lt;a href=\"{{ link2 }}\" class=\"enabled\"&gt; {% t global.english%}&lt;/a&gt;         &lt;/li&gt;         {% endif %}     &lt;/ul&gt;  &lt;/nav&gt;  마치며..  다국어를 적용하는데 꽤나 많은 시간을 허비했다. 또다른 누군가는 이 포스트를 보고 조금이나마 시간을 아낄 수 있기를..  ","categories": ["Jekyll"],
        "tags": [],
        "url": "https://jerry901.github.io/2020/02/2020-02-06-01/",
        "teaser":null},{
        "title": "Linux 터미널에서 쉘 스크립트를 실행가능하도록 변경",
        "excerpt":" 오늘은 리눅스 터미널에서 .sh 파일을 실행가능하게 만드는 방법에 대해 포스팅하고자 합니다.   Create HelloWorld.sh   먼저 샘플 파일로 HellowWorld.sh 파일을 작성합니다. 내용은 아래와 같습니다.   $ echo \"Hello World!\"   Run chmod +x HelloWorld.sh    chmod +x 커맨드를 실행해 스크립트 파일을 실행 가능하도록 만들면 ./HelloWorld.sh를 통해 쉘 스크립트 파일을 실행할 수 있습니다.   $ chmod +x HelloWorld.sh  $ ./HelloWorld.sh   Hellow World!  전역적으로 쉘 스크립트 파일을 실행 시키기    먼저 .sh 파일을 ~/.local/bin 경로로 옮긴 후, cd ~/.local/bin 경로로 이동합니다. ~/.local/bin/ 경로는 리눅스 사용자들에게 기본적으로 제공 되는 빈 폴더입니다. 일반적으로 운영체제 설치와 동시에 $PATH 변수에 추가 됩니다.   $ mv ./HellowWorld.sh ~/.local/bin; cd ~/.local/bin/  사실 .sh 확장자는 해당 파일이 쉘 스크립트로 작성된 파일이라는 것을 명시해주는 역할만 할 뿐 파일의 실행 가능 여부에는 영향을 미치지 않습니다. 따라서 아래와 같은 트릭을 써보죠.   #쉘 스크립트 파일을 ~/.local/bin/ 경로로 이동시킨다 하더라도 chmod +x filname 커맨드는 반드시 최초 1회 실행해야합니다.   $ mv ./HelloWorld.sh HelloWorld  파일명으로 쉘 스크립트 파일을 실행시키기    이제 모든 경로에서 HelloWorld 파일을 실행 시킬 수 있습니다.   $ cd  $ HelloWorld   Hello World!   $ cd Documents  $ HelloWorld   Hello World!  ","categories": ["Linux"],
        "tags": [],
        "url": "https://jerry901.github.io/2020/02/2020-02-07-01/",
        "teaser":null},{
        "title": "HackerRank 알고리즘 해설 : Minimum Swaps 2",
        "excerpt":"문제 해설  우선, 테스트 케이스로 주어지는 모든 배열은 1 부터 n 까지의 모든 정수를 포함하며, 중복이 허용되지 않으므로, 특정 index에 존재하는 정수의 값은 sorting이 되었을 때 해당 정수가 위치해야만 하는 index의 정보를 담고있다고 말할 수 있다. 다시말해 모든 배열 요소들은 arr[x] = x + 1를 만족해야만 한다 (ex. arr[4] = 5). 따라서 swap 함수를 이용해 위치를 바꾸어야하는 경우는 arr[i] != i+1인 경우이다.  최소한의 swap을 통해 배열을 정렬하기 위한 대략적인 알고리즘은 다음과 같다.   (배열의 인덱스는 0부터 시작하지만 배열 내의 정수는 1 부터 시작한다. 따라서 연산 과정에서 인덱스에 +1 또는 -1을 해야하므로 머리가 약간 아플 수 있음)      arr 전체를 반복문을 돈다.   arr[i] != i+1 이라면 arr[i] 와 arr[arr[i] - 1]를 swap()한다.   만약 swap을 한 이후에도 arr[i] != i+1 이라면 arr[i] == i+1이 될 때 까지 두번째 과정을 반복한다.   i++   예시  {5, 3, 1, 2, 6, 4} swap(0, 4) arr[0] != 1 이므로, arr[0]을 arr4와 교환한다.   {6, 3, 1, 2, 5, 4} swap(0, 5)   {4, 3, 1, 2, 5, 6} swap(0, 3)   {2, 3, 1, 4, 5, 6} swap(0, 1)   {3, 2, 1, 4, 5, 6} swap(0, 2)   {1, 2, 3, 4, 5, 6}   위와 같은 경우에는, i == 0 에서 모든 sorting이 완료된다.   소스 코드  // Written in c++ int num_of_swap; vector&lt;int&gt; arr; // Changed arr to global variable  int swap(int curIndex){     if(arr[curIndex] == curIndex+1)         return 0;      int temp = arr[curIndex];     arr[curIndex] = arr[temp-1];     arr[temp-1] = temp; \t\t     num_of_swap++;      return 1; }  // Complete the minimumSwaps function below. int minimumSwaps(vector&lt;int&gt; arr) {     for(int i = 0; i &lt; arr.size(); i++){         while(swap(i));     } \t\t     return num_of_swap; }  ","categories": ["HackerRank","Algorithms"],
        "tags": [],
        "url": "https://jerry901.github.io/2020/02/2020-02-21-01/",
        "teaser":null},{
        "title": "AWS 환경에 Node.js 어플리케이션 만들기",
        "excerpt":"  오늘은 아마존 클라우드 컴퓨팅 서비스인 EC2를 이용하여 node.js 어플리케이션을 만드는 방법에 대해 포스팅하고자 합니다.   References     자습서: Amazon EC2 인스턴스에서 Node.js 설치하기   생활코딩 : Server Side JavaScript   프로젝트 생성     먼저 작성한 node.js 파일을 저장할 프로젝트 디렉토리를 생성 후 해당 폴더로 이동한다.   $ mkdir node; cd ./node  다음으로 현재 경로를 npm 프로젝트로 초기화한다. $ npm init 명령어를 실행하면 몇가지 정보들을 입력하라고 하는데 그냥 빈칸으로 두고 Enter키를 입력해도 무방하다.    $ npm init   그리고나서 express.js를 설치한다.   $ npm install --save express   example.js 작성   vi example.js   아래 내용은 express.js 공식 홈페이지에 올라와있는 예제이다.   var express = require('express'); var app = express();  app.get('/', function (req, res) {   res.send('Hello World!'); });   app.listen(3000, function () {   console.log('Example app listening on port 3000!'); });   EC2 인바운드 정책에 포트 추가    다음과 같이 AWS Home &gt; EC2 &gt; 네트워크 및 보안 &gt; 보안 그룹으로 이동해 현재 AWS 인스턴스의 사용자정의 TCP 규칙에 3000 포트를 추가한다. (하단의 “인바운드” 탭을 누른후 “편집” 버튼을 클릭)      example.js 실행    다시 AWS 터미널로 돌아가서 example.js를 실행시킨다.   $ node example.js   결과 확인    http://AWS_public_DNS:3000 로 접근 시 Hello World!가 정상적으로 출력되는 것을 확인할 수 있다. Public DNS는 인스턴스 목록에서 확인할 수 있는 ec1-23-456-789-000.ap-northeast-0.compute.amazonaws.com 형식의 주소이다.  ","categories": ["Linux","AWS","Node.js"],
        "tags": [],
        "url": "https://jerry901.github.io/2020/03/2020-03-04-01/",
        "teaser":null},{
        "title": "Node.js 템플릿 엔진 PUG 사용법",
        "excerpt":"  오늘은 Node.js 의 템플릿 엔진 PUG의 설치 및 사용법에 대해 간단히 포스팅하겠습니다.   Template Engine ?    템플릿 엔진은 동적인 데이터 결과를 정적으로 구성되어있는 틀에 끼워 넣기위해 사용됩니다.  예를들면 사용자 정보 조회 페이지와 같은 경우, 기본적인 틀(HTML)은 같지만, 각 사용자에게 독립적인 데이터를 제공해야 합니다. 이러한 경우, 기본적인 틀은 미리 작성해두고 새로운 조회 데이터만 틀에 끼워넣어 응답을 보낸다면 업무가 훨씬 수월해지겠죠?   PUG 설치    npm 프로젝트 디렉토리로 이동 후 먼저 core-js를 업그레이드 해줍니다. (이걸 업데이트하지 않으니 몇가지 오류가 뜨더라구요…)   $ npm update core-js   pug를 설치하고, npm project root directory에 views 폴더를 생성합니다. –save 옵션을 입력하면 package.json 파일에 의존성이 기록되어 추후 모듈 관리가 편리합니다.    $ npm install pug --save  $ mkdir views   temp.pug 파일 생성    views 폴더로 이동해 temp.pub 파일을 생성하고 다음과 같이 입력합니다. .pug 파일에서 태그 간의 상호 계층 구조는 들여쓰기로 표현되는데, rendering 과정에서 템플릿 엔진은 위와 같이 간소화 된 코드들을 HTML 태그들로 변환해줍니다. 또한 간단한 로직을 구현할 수도 있습니다. 그러나 pub 파일에서는 Controller에서 넘겨받은 데이터를 출력하기 위해 ‘=’ 연산자를 사용하므로, 대입 연산이라는 것을 명시해주기 위해 반드시 문장 맨 앞에 ‘-‘를 입력해야 합니다.   html     head         title= _title     body         h1 hello Pug!         ul             - for(var i=0; i&lt;5; i++)                 li coding         div= time   app.js 작성    다음과 같은 내용을 app.js에 입력합니다. res.render() 메서드는 Key : value의 형식의 두번째 파라미터를 템플릿 엔진에 넘겨주고, 넘겨진 키는 temp.pug 파일에서 변수로서 사용할 수 있습니다.  이것이 템플릿 엔진을 사용하는 핵심적인 이유라고 할 수 있습니다.  var express = require('express'); var app = express();  app.locals.pretty = true; // beatify the html code made with template engine  app.set('views', './views'); // set the directory where your template files exist app.set('view engine', 'pug'); // set which template engine to use  app.get('/template', function(req, res){ // routing the request      res.render('temp', {time: Date(), _title: 'PUG'}); });  app.listen(3000, function () {   console.log('Example app listening on port 3000!'); });   결과 확인    http://localhost:3000/template (local server의 경우) 또는 http://AWS_PUBLIC_DNS:3000/template:3000 으로 접근하면 결과를 확인할 수 있습니다.     ","categories": ["Linux","Node.js"],
        "tags": [],
        "url": "https://jerry901.github.io/2020/03/2020-03-06-01/",
        "teaser":null},{
        "title": "Node.js 어플리케이션에서 GET, POST 방식 요청 처리",
        "excerpt":"  이전 포스트에서는 Node.js 템플릿 엔진 Pug에 관해 포스팅했습니다. 이번 포스트에서는 GET 방식, POST 방식을 통해 요청된 데이터를 처리하는 방법에 대해 알아보겠습니다.     [Node.js] 템플릿 엔진 PUG 간단 사용법   GET 데이터 처리하기   form_get.pug 파일 생성    먼저 Input box, Text area, Submit 버튼으로 구성된 템플릿을 작성할 것입니다. 아래 템플릿으로 렌더링된 HTML 페이지는 submit 버튼을 클릭할 시 ‘/get_receiver’ 요청을 보냅니다. form_get.pug 파일을 다음과 같이 작성해주세요.  doctype html html     head         meta(charset='utf-8')     body         form(action='/get_receiver' method='GET')             p                 input(type='text' name='title')             p                 textarea(name='description')             p                 input(type='submit')   get.js 파일 작성    GET Method를 통해 들어온 요청의 데이터들은 Request 객체의 프로퍼티중 하나인 query에 담겨있습니다. 따라서 다음과 같이 get.js 파일을 작성해주세요.  var express = require('express'); var app = express();  app.locals.pretty = true; app.set('views', './views'); app.set('view engine', 'pug');  app.get('/form_get', function(req, res){          res.render('form_get');  });  app.get('/get_receiver', function(req, res){          var title = req.query.title;          var description= req.query.description;         res.send(title+', '+description); });  app.listen(3000, function () {   console.log('Example app listening on port 3000!'); });   결과 확인    먼저 get.js를 실행합니다.   $ node get.js     http://base_url/form_get로 접근하면 Form 작성 페이지를 확인 할 수 있습니다. 데이터를 입력하고 제출 버튼을 클릭해보겠습니다.     GET 메서드로 보낸 데이터가 성공적으로 처리되어 돌아왔음을 확인할 수 있습니다.   POST 데이터 처리하기   form_get.pug 파일 생성    form_post.pug 파일을 다음과 같이 작성합니다. 내용은 form_get.pug 거의 비슷하지만 Form Tag의 Action이 POST Method로 변경되었습니다.  doctype html html     head         meta(charset='utf-8')     body         form(action='/post_receiver' method='POST')             p                 input(type='text' name='title')             p                 textarea(name='description')             p                 input(type='submit')  body-parser 설치    POST 요청을 처리하기 위해서는 Request 객체의 body 프로퍼티를 사용해야하는데, body 프로퍼티는 default로 undefined가 할당되어있습니다. 이 문제를 해결하기 위해서는 body-parser라는 node.js 모듈을 설치해야합니다. 웃깁니다. POST 요청을 처리하기위해 다른 모듈을 설치해야한다니.. 따라서 다음과 같이 body-parser를 설치해주세요.   $ npm install body-parser  post.js 파일 작성    get.js 파일과 다른 점은 app 객체가 body-parser 모듈을 사용할 수 있도록 설정해준 것과, app.post() Method의 등장입니다. 다음과 같이 post.js 파일을 작성해 주세요. 무작정 복사해서 붙여넣기 보다는 한번 따라서 타이핑 해보는 것을 추천드립니다.  var express = require('express'); var bodyParser= require('body-parser'); var app = express();  app.locals.pretty = true; app.set('views', './views'); app.set('view engine', 'pug'); app.use(bodyParser.urlencoded({extended: false}));  app.get('/form_post', function(req, res){         res.render('form_post'); });  app.post('/post_receiver', function(req, res){         var title = req.body.title;         var description= req.body.description;         res.send(title+', '+description); });  app.listen(3000, function () {   console.log('Example app listening on port 3000!'); });   결과 확인    먼저 post.js를 실행합니다.   $ node post.js    http://base_url/form_post로 접근하면 Form 작성 페이지를 확인 할 수 있습니다. 데이터를 입력하고 제출 버튼을 클릭해보겠습니다.     POST 메서드로 보낸 데이터가 성공적으로 처리되어 돌아왔음을 확인할 수 있습니다.  ","categories": ["Linux","Node.js"],
        "tags": [],
        "url": "https://jerry901.github.io/2020/03/2020-03-06-02/",
        "teaser":null}]
