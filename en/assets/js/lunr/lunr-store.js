var store = [{
        "title": "Hello",
        "excerpt":"This is my new blog   2020-01-26 12:47:03 +0900   ","categories": ["Jekyll","Update"],
        "tags": [],
        "url": "https://jerry901.github.io/en/2020/01/2020-01-26-01/",
        "teaser":null},{
        "title": "Jekyll Install on Ubuntu 18.04 LTS",
        "excerpt":" The most common environment for publishing github pages is to use Jekyll plugin on macOS or Linux. So today, I am going to provide you with guided steps on how to install a static site generator called Jekyll on Ubuntu 18.04 LTS environment.   Setting environment   Jekyll is written in Ruby language, which means you must install to run it,  but you might not want to just use “apt-get” pakage manager (homebrew in case of MacOS).  this is why : Installing Ruby with a pakage manager can get you into such deep trouble because each software written in Ruby(a.k.a gems) has different versions of Ruby to be installed with.  By using rbenv, you can change which version of Ruby to use whenever it’s needed. Therefore, The first step you might need to do is to install the Ruby using rbenv which is one of the Ruby version management softwares    - Install dependencies   Run these commands on shell. The apt-get update command will do nothing but update the list of softwares that your system may need.   $ sudo apt-get update  $ sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev software-properties-common libffi-dev nodejs    - Install rbenv   $ git clone https://github.com/rbenv/rbenv.git ~/.rbenv    - Add environment variables   Check if these variables are added to ~/.bashrc file after running these commands.   $ echo 'export PATH=\"$HOME/.rbenv/bin:$PATH\"' &gt;&gt; ~/.bashrc  $ echo 'eval \"$(rbenv init -)\"' &gt;&gt; ~/.bashrc  $ exec $SHELL    - Install ruby-build   $ git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build  $ echo 'export PATH=\"$HOME/.rbenv/plugins/ruby-build/bin:$PATH\"' &gt;&gt; ~/.bashrc  $ exec $SHELL    - Rehash rbenv   rbenv creates shims for all the commands ( ruby , irb , rake , gem and so on) across all your installed versions of Ruby. This process is called rehashing. Every time you install a new version of Ruby or install a gem that provides a command, run rbenv rehash to make sure any new commands are shimmed.   $ rbenv rehash    - Install Ruby with rbenv    The version of Ruby that i’m using currently is 2.6.3 and i haven’t had any issues with it, but you can definately choose the version depending on your preference   $ rbenv install 2.6.3   $ rbenv global 2.6.3   $ rbenv rehash     - Install Jekyll   If you install Ruby with rbenv, you would probably get gem command installed together.  gem is one of the gems that Ruby can install, so you can call this gem on you command line. gem command is used to install the other gems written in Ruby. This seems to me like it does the same thing as what apt-get command does on Linux.   $ gem install jekyll   - Install bundler   What bundler does is managing each gem’s application depndency. In case that a gem is dependant on the other gem, you can write these dependencies in a file called Gemfile, and install those gems easily with a command bundle install.   $ gem install bundler   Getting started with Jekyll   - Create a new Jekyll project   If you want publish github pages, the format of your project folder’s name must be github_username.githubio.  After creating a new Jekyll project with jekyll new command, you can run your local server by running jekyll serve command and check if you local server works with making a connection to http://localhost:4000.   $ Jekyll new project_name    $ cd project_name  ~/project_name $ jekyll serve    - Example of Bundler usage   Move to your project’s root directory, and then open Gemfile   ~/project_name $ vi Gemfile  Add a dependency like below(any line). jekyll_plugins allows us to work with graphical admin pages while you are working on our jekyll project.   gem 'jekyll-admin', group: :jekyll_plugins  Run bundle install command to install the plugin   $ bundle install  $ cd ~/project_name   ~/project_name $ jekyll serve   Now we can check if the plugin works fine by connecting to http://localhost:4000/admin/   References   - Stack overflow - How do RVM and rbenv actually work?  ","categories": ["Jekyll"],
        "tags": [],
        "url": "https://jerry901.github.io/en/2020/01/2020-01-26-02/",
        "teaser":null},{
        "title": "Configuring Vim editor",
        "excerpt":"  I want to share my configuration of vim editor. Paste the following into ~/.vimrc to make these settings work. Run the command below and create the file if ~/.vimrc does not exist.   $ touch ~/.vimrc        $ vi ~/.vimrc  \" syntax hilight  syntax on   set nocompatible  \" search result hilight  set hlsearch   \" line number  set nu   \" auto indent  set autoindent   set scrolloff=2  set wildmode=longest,list   \" tag select  set ts=4   \" st select  set sts=4   \" scroll bar width set sw=1   \" automatically save when moving to another file  set autowrite   \" automatically re-load if current file has been changed externally  set autoread   \" C style indent  set cindent   set history=100  \" always show status bar   set laststatus=2   \" indent width (4 = 4 spaces) set shiftwidth=4   set smarttab set smartindent set softtabstop=4 set tabstop=4  \" show the current cursor  set ruler   set statusline=\\ %&lt;%l:%v\\ [%P]%=%a\\ %h%m%r\\ %F\\  \" file encoding  set fileencoding=utf-8   \" when press backspace at line end, start or indent, move to previous line  set backspace=eol,start,indent   \" incremental searching  set incsearch   \" ignore case, set ic also works  set ignorecase   \" terminal encoding  set tenc=utf-8        \" korean files to euc-kr, uni-code to uni-code  set fencs=ucs-bom,utf-8,euc-kr.latin1   \" key mappings Leader key  let mapleader=\",\"  \" allow use mouse  \" F7 to turn it on map &lt;F7&gt; &lt;ESC&gt;:set mouse=a&lt;CR&gt; \" F8 to turn it off map &lt;F8&gt; &lt;ESC&gt;:set mouse-=a&lt;CR&gt;  \" key mappings  \" insert mode inoremap jk &lt;esc&gt;  \" normal mode nnoremap &lt;S-l&gt; $ nnoremap &lt;S-h&gt; ^ nnoremap d&lt;S-l&gt; d$ nnoremap d&lt;S-h&gt; d^ nnoremap &lt;Tab&gt; &gt;&gt; nnoremap &lt;S-Tab&gt; &lt;&lt; nnoremap &lt;C-k&gt; :m--&lt;CR&gt;== nnoremap &lt;C-j&gt; :m +1&lt;CR&gt;== nnoremap &lt;S-k&gt; k  \" to avoid openning help when pressed Shift-k nnoremap &lt;leader&gt;h &lt;S-k&gt;  \" visual mode vnoremap &lt;S-l&gt; $ vnoremap &lt;S-h&gt; ^  ","categories": ["Linux"],
        "tags": [],
        "url": "https://jerry901.github.io/en/2020/01/2020-01-27-01/",
        "teaser":null},{
        "title": "Publishing Github blog with Jekyll",
        "excerpt":"  In my previous post, I dealed with Jekyll Install on Ubuntu 18.04 LTS. Today, let’s take a look at how to publish Gihub pages with Jekyll   Create a new Github Repository     First of all, You need to create a new Github repository in order to upload static pages created by Jekyll. Repository name field should be formatted as username.github.io. Tnen, this name will work as a domain of your site.      Download a theme    Secondly, Pick a theme here that you might want to apply on your bolg.  What i picked was Minimal Mistakes theme which is one of the most popular Jekyll themes and also this blog was made with.    Run the commands below to install Minimal Mistakes.  If you chose another theme for your site, change the URL parameter of $ git clonecommand to the URL of the theme you picked.   $ cd ~ $ git clone https://github.com/mmistakes/minimal-mistakes.git  Build the project  $ cd minimal-mistakes $ bundle exec jekyll serve    If you see the result below, the build has done succesfully.  Configuration file: /home/userName/minimal-mistakes/_config.yml             Source: /home/userName/minimal-mistakes        Destination: /home/userName/minimal-mistakes/_site  Incremental build: disabled. Enable with --incremental        Generating...         Jekyll Feed: Generating feed for posts                     done in 0.199 seconds.  Auto-regeneration: enabled for '/home/userName/minimal-mistakes'     Server address: http://127.0.0.1:4000     Server running... press ctrl-c to stop.    Check if your local server works well by connecting to  http://127.0.0.1:4000/ or http://localhost:4000/.   Commit sources to the repository    Clone your userName.github.io repository, and copy the files in minimal-mistakes directory to the local repositroy.  Then, your pages will be published on github.   $ cd ~ $ git clone repository_URL  $ cp -r minimal-mistakes/* local_repo_folder_name $ cd local_repo_folder_name $ git add . $ git commit -m \"hello my blog\" $ git push origin master   Go to https://userName.github.io and see if your blog has been published successfully. It might take a few munites to be able to see the changes.  ","categories": ["Jekyll"],
        "tags": [],
        "url": "https://jerry901.github.io/en/2020/01/2020-01-27-02/",
        "teaser":null},{
        "title": "A Guide to applying multilingual feature to github pages",
        "excerpt":" On this post, I will provide you guys with some guided steps on how to make your Github pages multilingual using one of Jekyll plugins.  To apply the multilingual feature, It is better to use plugin, but Github does not support any other plugins with itself other than a few basic plugins for security reasons.  Therefore, uploading a project with some plugins will cause an Error during the project build process. However, it’s not that there is no way out at all. It might help us skip the build process of Github to push pages that have been generated on your local environment to the master branch**. Also, we can still control the versions of your Jekyll project by creating a new branch for you projects to be pushed.  We can barely find information on applying multilingual feature to the github blog, so I hope this post will help many people have their Github pages more global.   jekyll-multiple-laguages plug-in installation   There are several ways to install jekyll-multiple-laguages-plugin. What i have chosen from those ways is to use git submodule* because depending on the theme that I use, there may be issues related to the dependencies of gems. What you have to do first is to go to **root directory of your Jekyll project and execute the following command:   $ git submodule add git://github.com/screeninteraction/jekyll-multiple-languages-plugin.git _plugins/multiple-languages  $ ls _plugins/  If you can see this result from running ls _plugins/ command,  it should have been installed successfully.  multiple-languages   Setting _config.yml file   Add the information of languages you want to support to the _config.yml file.  The first element of it will be used as the default language  # languages # default langages : \"ko\"  languages: [\"ko\", \"en\"]  Directory structure  In the Jekyll project without multiple-languages-plugin,  Jekyll builds the .md files under _post folder in the root directory of your project. However, if you install jekyll-multiple-languages-plugin,  jekyll serve command will build the _posts folder under the _i18n directory.  Therefore, the following directory structure is required:  project_root/ -- _i18n/ ---- en/ ------ _post/ -------- yyyy-mm-dd-01.md # your posts / .md -------- yyyy-mm-dd-02.md -------- yyyy-mm-dd-03.md          ... ---- ko/ ------ _post/ -------- yyyy-mm-dd-01.md # your posts / .md -------- yyyy-mm-dd-02.md -------- yyyy-mm-dd-03.md          ... ---- en.yml ---- ko.yml   Setting lanugages.yml files  en.yml (example)  global:   english: Eng    korean: Kor pages:   home: Home   work: Work titles:   pagination: Pagination  ko.yml (example)  global:   english: Eng    korean: Kor pages:   home: Home   work: Work titles:   pagination: Pagination   Visiting multiligual pages  Default language page (Korean)   https://blogurl.io/yyyy-mm-dd-01  https://localhost:4000/yyyy-mm-dd-01   Multiligual pages (English)   https://blogurl.io/en/yyyy-mm-dd-01  https://localhost:4000/en/yyyy-mm-dd-01   Publishing automatically  Create a source branch and set it to the default branch    Run these commands below in you local repository;  git push -u option does nothing, but later on you can just simply push your sources without typing the name of branches.   $ git checkout -b source master  $ git push -u origin source  And then, go to Github web &gt; your repository &gt; Settings &gt; Branches &gt; Default branch, set the source branch to the default branch.   Rakefile  Run vi Rakefile or vi rakefile on the root directory of your jekyll project. and add the flowing. If there is no rakefile, you can just create a new one.  # Auto publish # Change your GitHub reponame GITHUB_REPONAME = \"username/username.github.io\"  desc \"Generate blog files\" task :generate do   Jekyll::Site.new(Jekyll.configuration({     \"source\"      =&gt; \".\",     \"destination\" =&gt; \"_site\"   })).process end  desc \"Generate and publish blog to gh-pages\" task :publish =&gt; [:generate] do   Dir.mktmpdir do |tmp|     cp_r \"_site/.\", tmp      pwd = Dir.pwd     Dir.chdir tmp      system \"git init\"     system \"git add .\" \tmessage = \"Site updated at #{Time.now.utc}\" \tsystem \"git commit -m #{message.inspect}\"     system \"git remote add origin https://github.com/#{GITHUB_REPONAME}.git\"     system \"git push origin master --force\"      Dir.chdir pwd   end end  Run rake publish    Now you can easily publish your pages that have been generated in you local environment to the master branch by runningrake publish or bundle exec rake publish, and push your project to the source branch by running git push command   Language switcher    Now that you got a multilingual feature, you might need a langage switcher. Here’s an example source of the language switcher that you can see on the top of this blog. I added it below the &lt;nav&gt; tag of masthead.html. (CSS might need to be configured)   &lt;nav id=\"lang-sel\" &gt;     &lt;ul class=\"lang\"&gt;         {% capture link1 %}{{ site.baseurl_root }}{{ page.url}}{% endcapture %}         {% capture link2 %}{{ site.baseurl_root }}/en{{ page.url}}{% endcapture %}         {% if site.lang == \"ko\" %}         &lt;li class=\"masthead_menu-item visible-links\"&gt; \t        &lt;a href=\"{{ link1 }}\" class=\"enabled\"&gt;{% t global.korean%} &lt;/a&gt;|&lt;a href=\"{{ link2 }}\"&gt; {% t global.english%}&lt;/a&gt;         &lt;/li&gt;         {% elsif site.lang == \"en\" %}         &lt;li class=\"masthead_menu-item lang\"&gt; \t        &lt;a href=\"{{ link1 }}\"&gt;{% t global.korean%} &lt;/a&gt;|&lt;a href=\"{{ link2 }}\" class=\"enabled\"&gt; {% t global.english%}&lt;/a&gt;         &lt;/li&gt;         {% endif %}     &lt;/ul&gt;  &lt;/nav&gt;  Finishing this post..    i have spent a lot of time to make this feature work out. I hope somebody can get some help with this, and save their time.  ","categories": ["Jekyll"],
        "tags": [],
        "url": "https://jerry901.github.io/en/2020/02/2020-02-06-01/",
        "teaser":null},{
        "title": "Making .sh files executable on Linux terminal",
        "excerpt":" Today, I’m going to post about the way how to make .sh files executable on Linux command line.   Create HelloWorld.sh    First, Create HelloWorld.sh file like below.   $ echo \"Hello World!\"   Run chmod +x HelloWorld.sh     Run chmod +x command, then now you can execute HelloWorld.sh by running ./HelloWorld.sh command   $ chmod +x HelloWorld.sh  $ ./HelloWorld.sh   Hellow World!  How to globally execute .sh files    To globally execute your .sh files,  you need to move them to ~/.local/bin/. This folder is given to the user with nothing(maybe) inside once the OS is installed, and is basically added to the $PATH variable.    $ mv ./HellowWorld.sh ~/.local/bin; cd ~/.local/bin/   Actually, The extension .sh is just to let users know that it is .sh file, and do nothing special. So, let’s do a trick like this.  #Althogh you move your shell script file to ~/.local/bin/, you still have to run chmod +x filname command at the fist time.   $ mv ./HelloWorld.sh HelloWorld  Run HelloWorld file   Now you can globally execute the shell script file anywhere as if it one of the commands that you have by typing HelloWorld on your command line.   $ cd  $ HelloWorld   Hello World!   $ cd Documents  $ HelloWorld   Hello World!  ","categories": ["Linux"],
        "tags": [],
        "url": "https://jerry901.github.io/en/2020/02/2020-02-07-01/",
        "teaser":null},{
        "title": "HackerRank Solution : Minimum Swap 2",
        "excerpt":"Solution  The basic idea is this : Any of arr[i] means the index where it actually have to go to because all of the cases are consecutive,  from ‘1’ to ‘n’. There are no cases like “{1, 2, 4, 8, 9}” as a simple example.  What i did was to keep swapping the elements arr[i] and arr[arr[i]-1] till the element of arr[i] becomes i+1 for every loop;  arr[0] should become ‘1’, arr[1] should become ‘2’, arr[3] = ‘3’ and so on.  This worked very well and i think it’s simple. i’m sharing my code just in case for someone it could be a little help. Happy practicing.   Example case  {5, 3, 1, 2, 6, 4} swap(0, 4) cuz number 5 must be at the index 4 which is 5th index of its array   {6, 3, 1, 2, 5, 4} swap(0, 5)   {4, 3, 1, 2, 5, 6} swap(0, 3)   {2, 3, 1, 4, 5, 6} swap(0, 1)   {3, 2, 1, 4, 5, 6} swap(0, 2)   {1, 2, 3, 4, 5, 6}   In this case, we can get the array fully sorted only at index ‘0’   Source  // Written in c++ int num_of_swap; vector&lt;int&gt; arr; // Changed arr to global variable  int swap(int curIndex){     if(arr[curIndex] == curIndex+1)         return 0;      int temp = arr[curIndex];     arr[curIndex] = arr[temp-1];     arr[temp-1] = temp; \t\t     num_of_swap++;      return 1; }  // Complete the minimumSwaps function below. int minimumSwaps(vector&lt;int&gt; arr) {     for(int i = 0; i &lt; arr.size(); i++){         while(swap(i));     } \t\t     return num_of_swap; }  ","categories": ["HackerRank","Algorithms"],
        "tags": [],
        "url": "https://jerry901.github.io/en/2020/02/2020-02-21-01/",
        "teaser":null},{
        "title": "Making a node.js application on AWS Server",
        "excerpt":"  AWS has been the most popular web service for years, and most of the companies that you might want to give your resume to would probably require your abilities of some AWS services. Therefore, there is no wonder that you must know how to use AWS or how it works if you want to get a job as a Web developer. Today, I’m going to post about how to make a basic node.js application on AWS.   References     Tutorial: Setting Up Node.js on an Amazon EC2 Instance   Create a Project     First of all, make a directory to save your source file, and go to the directory.    $ mkdir node; cd ./node  For the next, Initialize current directory as a npm project. There will be some break point asking you to write some informations of this project but those are not important at all. Just keep hitting Enter.    $ npm init  Install express.js   $ npm install --save express   Write example.js file   vi example.js   This code below is a sample code which is on the official Web site of Express.js   var express = require('express'); var app = express();  app.get('/', function (req, res) {   res.send('Hello World!'); });   app.listen(3000, function () {   console.log('Example app listening on port 3000!'); });   Add a Inbound Rule to the EC2 Security Group    On the AWS Web, move to AWS Home &gt; EC2 &gt; NETWORK &amp; SECURITY &gt; Security Groups, click “Edit” button in “Inboud” tab, and add a Custom TCP Rule (port: 3000).      Run example.js    Lets go back to the AWS Terminal, and run example.js    $ node example.js   Check the result    When you request http://AWS_public_DNS:3000 on your browser, you would be able to see the Hello world! as a result. Public DNSis an address that you can see on the list of your AWS instances which is exactly like ec1-23-456-789-000.ap-northeast-0.compute.amazonaws.com.  ","categories": ["Linux","AWS","Node.js"],
        "tags": [],
        "url": "https://jerry901.github.io/en/2020/03/2020-03-04-01/",
        "teaser":null},{
        "title": "Simple guide for the template engine PUG",
        "excerpt":"  Today, we are gonna take a quick look at Installing and a simple usage of the Node.js template engine called Pug   Template Engine ?    Template engine is used to generate HTML pages with vairables in them. For example, in case of user information page, every user wll see the same template but gets different information depending on the user who has requested the page. In this case, it’s better to have one specific HTML template and fiil the data which is selected with user ID.   Install PUG    Move to the root directory of the npm project, and update the core-js.   $ npm update core-js   Install Pug, and create a directory named views. If you use –save option, you will get Pub in your package.json file as one of the dependencies.    $ npm install pug --save  $ mkdir views   Create temp.pug    Move to Views and create temp.pug. In .pug files, The html hierarchy is expressed with indent of each line, and the template engine translate code like below to HTML tags. Also, we can do some logic in .pug files, but we need to make sure that we mean to use logic by adding Dash( - )` at the beginning of the line since it uses ‘=’ operator to print data which is given by Controller.  html     head         title= _title     body         h1 hello Pug!         ul             - for(var i=0; i&lt;5; i++)                 li coding         div= time   Wirte code in app.js file    Write app.js file or create it like below. res.render() method accepts the parameter formatted in Key : Value which is its second parameter, and theses can be used as variables in temp.pug file. This is the biggest reason why we use template engine.   var express = require('express'); var app = express();  app.locals.pretty = true; // beatify the html code made with template engine  app.set('views', './views'); // set the directory where your template files exist app.set('view engine', 'pug'); // set which template engine to use  app.get('/template', function(req, res){ // routing the request      res.render('temp', {time: Date(), _title: 'PUG'}); });  app.listen(3000, function () {   console.log('Example app listening on port 3000!'); });   Check the result   After running the server with command $ node app.js, go to http://localhost:3000/template (local server) or http://AWS_PUBLIC_DNS:3000/template:3000 (AWS) to check the result.     Perfect? Yeah.  ","categories": ["Linux","Node.js"],
        "tags": [],
        "url": "https://jerry901.github.io/en/2020/03/2020-03-06-01/",
        "teaser":null},{
        "title": "How to perform GET and POST requests on node.js applications",
        "excerpt":"  In my previous post, we took a look at a Node.js Template engine Pug. Today, I’m going to post about processing data requested by GET, POST Methods.     - [Node.js] Simple guide for the template engine PUG   Performing GET Request   Create form_get.pug    First of all, we are going to create a template which consists of Input box, Text area, and Submit button. This page will send ‘/get_receicer’ request when the submit button is pressed. Create a file named form_get.pug.  doctype html html     head         meta(charset='utf-8')     body         form(action='/get_receiver' method='GET')             p                 input(type='text' name='title')             p                 textarea(name='description')             p                 input(type='submit')   Create get.js    The data which has been given to server by GET Method is in ‘query’ which is a property of Request object. To process the data, create your get.js file like below.   var express = require('express'); var app = express();  app.locals.pretty = true; app.set('views', './views'); app.set('view engine', 'pug');  app.get('/form_get', function(req, res){          res.render('form_get');  });  app.get('/get_receiver', function(req, res){          var title = req.query.title;          var description= req.query.description;         res.send(title+', '+description); });  app.listen(3000, function () {   console.log('Example app listening on port 3000!'); });   Check the result    Run server by executing get.js command .   $ node get.js     Go to the form page by requesting http://base_url/form_get on your browser, Fill the form, and then press the submit button.     We can see the data we sent just sent has been processed sucessfully, and come back!   Performing POST Request   Create form_get.pug    Create form_post.pug like below . It is mostly the same as form_get.pug file, but the action of form tag has been chaged to Post Method.  doctype html html     head         meta(charset='utf-8')     body         form(action='/post_receiver' method='POST')             p                 input(type='text' name='title')             p                 textarea(name='description')             p                 input(type='submit')  Install body-parser    To process the data from Post Method, we need to you the property  body in the request object. However, Body property is set to the undefined by default, So we need to get a module that let us able to use the property called body-parser. Lets install the moudlue with a command below.   $ npm install body-parser  Create post.js    Add a code that allow app object to be able to use body-parser module, and we are going to use app.post() Method instead of app.get() method.  var express = require('express'); var bodyParser= require('body-parser'); var app = express();  app.locals.pretty = true; app.set('views', './views'); app.set('view engine', 'pug'); app.use(bodyParser.urlencoded({extended: false}));  app.get('/form_post', function(req, res){         res.render('form_post'); });  app.post('/post_receiver', function(req, res){         var title = req.body.title;         var description= req.body.description;         res.send(title+', '+description); });  app.listen(3000, function () {   console.log('Example app listening on port 3000!'); });   Check the result    먼저 post.js를 실행합니다.   $ node post.js    Go to the form page by requesting http://base_url/form_post on your browser, Fill the form, and then press the submit button.     We can see the data we sent just sent has been processed sucessfully, and come back!  ","categories": ["Linux","Node.js"],
        "tags": [],
        "url": "https://jerry901.github.io/en/2020/03/2020-03-06-02/",
        "teaser":null}]
